/*
 * Generated By SugarKubes Apr 14 2024
 */

const Monkey = require("../../models/Monkey");
/*
 * @oas [get] /monkeys
 * summary: "get monkeys"
 * tags: ["monkey"]
 * parameters: 
 *   - in: query
 *     name: page
 *     description: page
 *     schema:
 *       type: integer
 *   - in: query
 *     name: limit
 *     description: The numbers of items to return
 *     schema:
 *       type: integer
 *   - in: query
 *     name: filters
 *     description: Filters to search on specific 'columns'
 *     style: deepObject
 *     schema:
 *       type: object
 *       example: 'stringified array [{"column":{"title":"Name","field":"name","type":"â€¦Sort":"asc","id":0}},"operator":"=","value":"1"}]'
 *   - in: query
 *     name: orderBy
 *     style: deepObject
 *     description: object containing how to sort the items
 *     schema:
 *       type: object
 *       example: { "field": "asc", "test": -1, "field2": "desc" }
 *   - in: query
 *     name: select
 *     description: object containing fields want to be returned
 *     style: deepObject
 *     schema:
 *       type: object
 *       example: { "first_name": 1 }
 *   - in: query
 *     name: name
 *     description: object supports mongodb queries on objects. see https://mongoosejs.com/docs/api.html#query_Query or string name 
 *     schema:
 *       oneOf:
 *         - type: string
 *         - type: object
 *       example: { $gte: 5 } 
 *   - in: query
 *     name: alive
 *     description: object supports mongodb queries on objects. see https://mongoosejs.com/docs/api.html#query_Query or boolean alive 
 *     schema:
 *       oneOf:
 *         - type: boolean
 *         - type: object
 *       example: { $gte: 5 } 
 *   - in: query
 *     name: age
 *     description: object supports mongodb queries on objects. see https://mongoosejs.com/docs/api.html#query_Query or number age 
 *     schema:
 *       oneOf:
 *         - type: number
 *         - type: object
 *       example: { $gte: 5 } 
 * responses:
 *   "200":
 *     description: "get monkeys"
 *     schema:
 *       type: "Monkey"
 */
module.exports = async (req, res) => {
  try {
    let {
      sort,
      select,
      populate,
      limit,
      page,
      search,
      filters
    } = req.query;
    const {
      name,
      alive,
      age
    } = req.query;
    // The model query
    const find = {};
    let parsedFilters = null;
    // pagination object (search, sort, filter, etc);
    const where = {};
    if (filters && filters !== '[]') {
      parsedFilters = JSON.parse(filters);

      parsedFilters.forEach((f) => {
        let regexValue = {};
        if (f.column.type === 'boolean') {
          regexValue = f.value === 'checked' ? true : false;
        } else if (Array.isArray(f.value) && f.value.length > 0) {
          if (f.column.type === 'string') {
            regexValue = {
              $in: []
            };
            f.value.forEach((val) => {
              regexValue.$in.push(val)
            });
          } else {
            regexValue = {
              $or: []
            };
            f.value.forEach((val) => {
              regexValue.$or.push({
                $eq: val
              });
            });
          }
        } else if (f.column.type === 'numeric' || f.column.type === 'number') {
          regexValue = {
            $eq: f.value
          };
        } else {
          regexValue = {
            $regex: new RegExp(f.value, "ig")
          };
        }
        if (JSON.stringify(regexValue) !== '{}') find[f.column.field] = regexValue;
      });

    }


    // search
    if (search) {
      find.$or = [];
      find.$or.push({
        name: {
          $regex: new RegExp(search, "ig")
        }
      })
      if (search === 'true' || search === 'false') {
        find.$or.push({
          alive: search === 'true' ? true : false
        });
      }
      if (!isNaN(search)) {
        find.$or.push({
          age: {
            $eq: search
          }
        });
      };
    }

    // Validation
    // Pagination 
    if (sort && typeof sort === 'string') sort = JSON.parse(sort);
    if (typeof sort !== 'undefined' && sort !== '') {
      where.sort = sort;
    }
    if (typeof select !== 'undefined' && select !== '') {
      where.select = select;
    }
    if (typeof populate !== 'undefined' && populate !== '') {
      where.populate = populate;
    } else {
      where.populate = "";
    }
    if (typeof limit !== 'undefined' && limit !== '') {
      where.limit = isNaN(limit) ? limit : Number(limit);
    } else {
      where.limit = 10;
    }
    if (typeof page !== 'undefined' && page !== '') {
      where.page = isNaN(page) ? page : Number(page);
    } else {
      where.page = 0;
    }
    if (typeof search !== 'undefined' && search !== '') {
      where.search = search;
    } else {
      where.search = "";
    }
    if (typeof filters !== 'undefined' && filters !== '') {
      where.filters = filters;
    } else {
      where.filters = "";
    }
    where.offset = page * limit;
    // Model Validation 
    if (typeof name !== 'undefined') {
      try {
        find.name = JSON.parse(name)
      } catch (e) {
        find.name = name;
      }
    }
    if (typeof alive !== 'undefined') {
      try {
        find.alive = JSON.parse(alive)
      } catch (e) {
        find.alive = alive === 'false' ? false : true;
      }
    }
    if (typeof age !== 'undefined') {
      try {
        find.age = JSON.parse(age)
      } catch (e) {
        find.age = isNaN(age) ? age : Number(age);
      }
    }
    // @TODO handle safe area. Should be idempotent.

    // maybe with @sugar-safe-start
    // @sugar-safe-end

    // save
    const monkey = await Monkey.paginate(find, where); // @TODO populate: '<model name>'
    return res.json({
      monkeys: monkey
    });

  } catch (e) {
    console.error('GET => monkey', e);
    return res.status(500).json({
      error: e.message ? e.message : e
    });
  }
};